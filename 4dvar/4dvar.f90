module     param
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  implicit none

  !==============================================
  ! declare parameters
  !==============================================
  integer(kind=4), parameter :: ii = 3
  integer, parameter :: ikind2 = 8
  integer(kind=4), parameter :: nobs = 1
  integer(kind=4), parameter :: nt = 1600
!  integer(kind=4), parameter :: nt = 16000
!  integer(kind=4), parameter :: nt = 32000
  integer(kind=4), parameter :: ntd = 1

  !==============================================
  ! declare local variables
  !==============================================
  real(kind=8) :: a = 0.2
  real(kind=8) :: b = 0.2
  real(kind=8) :: c = 6
  real(kind=8) :: fn(ii,0:nt)=0
  real(kind=8) :: fn_ad(ii,0:nt)=0
  real(kind=8) :: fn_tl(ii,0:nt)=0
  real(kind=8) :: h = 5.0D-4
  real(kind=8) :: sigb = 0.2
  real(kind=8) :: sigm = 2
#ifdef CHECK
  real(kind=8) :: sigm_tmp = 0.0d0
  integer(kind=4) :: ic
#endif
  real(kind=8) :: sigo = 0.2
  real(kind=8) :: xb(ii)

contains
  subroutine param_constructor_ad
    !******************************************************************
    !******************************************************************
    !** This routine was generated by Automatic differentiation.     **
    !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
    !******************************************************************
    !******************************************************************
    implicit none

    !----------------------------------------------
    ! RESET ADJOINT MODULE VARIABLES
    !----------------------------------------------
    fn_ad(:,:) = 0._ikind2

  end subroutine param_constructor_ad
end module     param

module obsdata
  use param
  implicit none
  real(8) :: xobs(ii,nobs)
  real(8) :: xo(ii,0:nt)
  real(8) :: tobs(nobs), t
  real(8) :: x_fg(ii,0:nt)
#ifdef ANOTHER_FG
  real(8) :: x_fg2(ii,0:nt)
#endif
contains
  subroutine setobs
    implicit none
    real(8) :: dw(ii*nt)
    real(8) :: dw2(ii)
    integer(4) :: i, it, iobs

    tobs(1) = 0.4
    !obs data almost on the attractor
    xb(1)= 2.0659834; xb(2)=-0.2977757; xb(3)= 2.0526298

    call func_dw(h,dw2,ii)  
    do i=1,ii
       x_fg(i,0) = xb(i) + sigb*dw2(i) 
    enddo
!    x_fg(1,1) = -5.90851E+00; x_fg(2,1) = -1.91864E+00; x_fg(3,1) =  -1.11507E-02  
    call func_dw(h,dw,ii*nt)  
    do it=0,nt-1
       call func_ross( x_fg(:,it),fn(:,it) )
       do i=1,ii
          x_fg(i,it+1) = x_fg(i,it) + fn(i,it)*h + sigm*dw(i+it*ii)
       enddo
    enddo !firstguess

    xo(:,:) = -999
    do it=0,nt
       do iobs = 1,nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
             call func_dw(1.0d0,dw2,ii)  
             do i=1,ii
                xo(i,it) = x_fg(i,it) + sigo*dw2(i)
                xobs(i,iobs) = xo(i,it) 
             enddo
          endif
       enddo
#ifndef ANOTHER_FG
       write(11,'(a,10(1x,f14.7))') "x",it*h,x_fg(:,it),xo(:,it)
#endif
    enddo
#ifdef ANOTHER_FG
    call func_dw(h,dw2,ii)  
    do i=1,ii
       x_fg2(i,1) = xb(i) + sigb*dw2(i) 
    enddo
    call func_dw(h,dw,ii*nt)  
    do it=0,nt-1
       if(mod(it,100)==0) then
          call func_dw(h,dw2,ii)  
          do i=1,ii
#ifndef NOISELESS
             x_fg2(i,it) = x_fg(i,it) + sigm*dw2(i) 
#endif
          enddo
       endif
       call func_ross( x_fg2(:,it),fn(:,it) )
       do i=1,ii
#ifndef NOISELESS
          x_fg2(i,it+1) = x_fg2(i,it) + fn(i,it)*h + sigm*dw(i+it*ii)
#else
          x_fg2(i,it+1) = x_fg2(i,it) + fn(i,it)*h !+ sigm*dw(i+it*ii)
#endif
       enddo
    enddo !firstguess
    do it=0,nt
       write(11,'(a,10(1x,f14.7))') "x",it*h,x_fg2(:,it),xo(:,it)
    enddo
#endif
  end subroutine setobs
end module obsdata

program    main
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use mpi
  use param
  use obsdata
  use mtmod
  implicit none

  !==============================================
  ! declare local variables
  !==============================================
  real(kind=8) :: x(ii,0:nt)
#ifdef CALP
  real(kind=8) :: p(ii,0:nt)
#endif
  real(kind=8) :: xold(ii,0:nt)
!  real(kind=8) :: xx(ii,0:nt)
  real(kind=8) :: adx(ii,0:nt)
!  real(8) :: adxx(ii,0:nt)=0
  integer(kind=4) :: it, itr
  integer(kind=4) :: ntr  =10000000
  integer(kind=4) :: itr0 = 1000000
!  real(8) :: q0, q1, logr, ratio
!  real(8) ::  r=5d-3
  real(8) :: S=2.0d20
  real(8), parameter :: alp=1.d-2
  real(8) :: Sold, alp1, norm, tol=1d-7
!  real(8) :: Sold, alp1, norm, tol=1d-4
  integer(4) :: acc(0:1)=0
  integer(4) :: acc_all(0:1)=0
  real(8) :: dw(ii*nt)
  real(8) :: mean(ii,0:nt)=0.0  
  real(8) :: vari(ii,0:nt)=0.0  
  real(8) :: mean_all(ii,0:nt)=0.0  
  real(8) :: vari_all(ii,0:nt)=0.0  
  real(8) :: Z=0.0  
  real(8) :: Z_all=0.0  , dum
  integer(4) :: err, rank, size
#if 0
  integer(4), parameter :: mm=120
  real(8), parameter :: xmin=-1, xmax=2.5
  real(8) :: dx=(xmax-xmin)/mm
  real(8) :: dens(ntd,mm,mm)=0.0
  real(8) :: dens_all(ntd,mm,mm)=0.0
#endif
  integer(4) :: mx, my, i

  call sgrnd(1)

#ifdef READ_OBS
  tobs(1) = 0.4
  xb(1)= 2.0659834; xb(2)=-0.2977757; xb(3)= 2.0526298
  open(11,file="../ref/fort.11")
  do it=0,nt/2
     read(11,'(1x,10(1x,f14.7))') dum,x_fg(:,it),xo(:,it)
!     if(rank.eq.0)write(0,'(1x,10(1x,f14.7))') dum,x_fg(:,it),xo(:,it)
  enddo
  close(11)
  xobs(:,1) = xo(:,nt/2) 
#else
  call setobs
#endif

#ifdef ANOTHER_FG
  x(:,:) = x_fg2(:,:)
#else
  x(:,:) = x_fg(:,:)
#endif
#ifdef CHECK
  em_loop: do ic = 1,3
#endif
#ifdef CALP
  call fwd( x,S ,p)
#else
  call fwd( x,S )
#endif
  write(*,'(2i8,5(1x,1pe10.3))') itr, i, S, norm, x(:,nt)
  ens_loop: do itr=1,ntr
     !adj
     call fwd_ad( x, adx, S, 1.0d0 )
     !line search
     Sold = S
     alp1 = alp
     xold(:,:) = x(:,:)
     do i=1,100
        x(:,:)=xold(:,:)-alp1*adx(:,:)
#ifdef CALP
        call fwd( x,S ,p)
#else
        call fwd( x,S )
#endif
        if(S>Sold) then
           alp1 = alp1*0.5
        else
           exit
        endif
     enddo
!        write(0,*) itr, i, S
     norm=sum(adx(:,:)**2)
     if(mod(itr,10000)==0)write(*,'(2i8,5(1x,1pe10.3))') itr, i, S, norm, x(:,nt)
     if(norm<tol) then
        write(*,'(2i8,5(1x,1pe10.3))') itr, i, S, norm, x(:,nt)
        exit
     endif
!     if(norm<tol .or. abs(S-Sold)<1.d-12) exit
  enddo ens_loop
#ifdef CHECK
  if(ic==1) then
#endif
  open(12,file="fort.12")
  do it=0,nt
#ifdef CALP
     write(12,'(a3,20(1x,1pe12.5))') "Out", it*h, x(:,it), p(:,it)
#else
     write(12,'(a3,20(1x,1pe12.5))') "Out", it*h, x(:,it)
#endif
  enddo
  close(12)
#ifdef CHECK
  endif
#endif

#ifdef CHECK
!consitency check
#ifndef TRAPEZ
   do it = 0, nt-1
      call func_ross( x(:,it),fn(:,it) )
      do i = 1, ii
         sigm_tmp = sigm_tmp+((x(i,it+1)-x(i,it))/h-fn(i,it))**2*h
      enddo
   enddo
#else
   do it = 0, nt
      call func_ross( x(:,it),fn(:,it) )
   end do
   do it = 0, nt-1
      do i = 1, ii
         sigm_tmp = sigm_tmp+((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/2)**2*h
      enddo
  end do
#endif
   sigm_tmp = sqrt(sigm_tmp/(nt*h*ii))
   write(*,'(2i8,7(1x,1pe10.3))') itr, i, S, norm, x(:,nt), sigm_tmp, sigm
   sigm = sigm_tmp
   enddo em_loop
  open(13,file="fort.13")
  do it=0,nt
     write(13,'(a3,20(1x,1pe12.5))') "Out", it*h, x(:,it)
  enddo
  close(13)
#endif

end program    main

#ifndef TRAPEZ
#ifdef CALP
subroutine fwd( x, S ,p)
#else
subroutine fwd( x, S )
#endif
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param
  use obsdata
  implicit none

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(out) :: S
#ifdef CALP
  real(kind=8), intent(out) :: p(ii,0:nt)
#endif
  real(kind=8), intent(in) :: x(ii,0:nt)

  !==============================================
  ! declare local variables
  !==============================================
  integer(kind=4) :: i
  integer(kind=4) :: iobs
  integer(kind=4) :: it

  S = 0.0
  do i = 1, ii
     S = S+(x(i,0)-xb(i))**2/sigb**2/2
  end do
  !write(0,*) "S =", S
  do it = 0, nt-1
     call func_ross( x(:,it),fn(:,it) )
     do i = 1, ii
        S = S+((x(i,it+1)-x(i,it))/h-fn(i,it))**2/sigm**2/2*h
#ifdef CALP
        p(i,it+1) = ((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2
#endif
     end do
#ifdef DIV
     S = S + (x(1,it)+a-c)/2*h
#endif
  enddo
  do it = 0, nt
     do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
           do i = 1, ii
              S = S+(x(i,it)-xobs(i,iobs))**2/sigo**2/2
           end do
        endif
     end do
  end do
  !write(0,*) "S =",S

end subroutine fwd

subroutine fwd_ad( x, x_ad, S, S_ad )
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param
  use obsdata 

  implicit none

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(in) :: S
  real(kind=8), intent(in) :: S_ad
  real(kind=8), intent(in) :: x(ii,0:nt)
  real(kind=8), intent(inout) :: x_ad(ii,0:nt)

  !==============================================
  ! declare local variables
  !==============================================
  integer(kind=4) :: i
  integer(kind=4) :: iobs
  integer(kind=4) :: it

  !----------------------------------------------
  ! RESET GLOBAL ADJOINT VARIABLES
  !----------------------------------------------
  call zero_ad
  x_ad(:,:)=0.0
  do it = nt, 0, -1
     do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
!        if (abs(tobs(iobs)-it*h) .lt. h/2) then
           do i = 1, ii
              x_ad(i,it) = x_ad(i,it)+S_ad*(2*(x(i,it)-xobs(i,iobs))/sigo**2/float(2))
           end do
        endif
     end do
  enddo
  do it = nt-1, 0, -1
     call func_ross( x(:,it),fn(:,it) )
#ifdef DIV
     x_ad(1,it) = x_ad(1,it) + S_ad/2*h
#endif
     do i = 1, ii
        fn_ad(i,it) = fn_ad(i,it)+S_ad*((-2)*((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2/float(2))*h
        x_ad(i,it+1) = x_ad(i,it+1)+S_ad*(2*(1/h)*((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2/float(2))*h
        x_ad(i,it) = x_ad(i,it)+S_ad*(2*((-1)/h)*((x(i,it+1)-x(i,it))/h-fn(i,it))/sigm**2/float(2))*h
     end do
     call func_ross_ad( x(:,it),x_ad(:,it),fn_ad(:,it) )
  end do
  do i = 1, ii
     x_ad(i,0) = x_ad(i,0)+S_ad*(2*(x(i,0)-xb(i))/sigb**2/float(2))
  end do

end subroutine fwd_ad
#else
subroutine fwd( x, S )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use param
use obsdata

implicit none

!==============================================
! declare arguments
!==============================================
real(kind=8), intent(out) :: S
real(kind=8), intent(in) :: x(ii,0:nt)

!==============================================
! declare local variables
!==============================================
integer(kind=4) :: i
integer(kind=4) :: iobs
integer(kind=4) :: it

S = 0.0
do i = 1, ii
  S = S+(x(i,0)-xb(i))**2/sigb**2/2
end do
do it = 0, nt
  call func_ross( x(:,it),fn(:,it) )
end do
do it = 0, nt-1
  do i = 1, ii
    S = S+((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/2)**2/sigm**2/2*h
  end do
#ifdef DIV
  S = S+((x(1,it+1)+x(1,it))/2+a-c)/2*h
#endif
enddo
do it = 0, nt
  do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
      do i = 1, ii
        S = S+(x(i,it)-xobs(i,iobs))**2/sigo**2/2
      end do
    endif
  end do
end do
#ifdef DIV
S = S+(x(1,0)+a-c)/4*h
S = S+(x(1,nt)+a-c)/4*h
#endif
end subroutine fwd

subroutine fwd_ad( x, x_ad, S, S_ad )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use param
use obsdata

implicit none

!==============================================
! declare arguments
!==============================================
real(kind=8), intent(in) :: S
real(kind=8), intent(in) :: S_ad
real(kind=8), intent(in) :: x(ii,0:nt)
real(kind=8), intent(inout) :: x_ad(ii,0:nt)

!==============================================
! declare local variables
!==============================================
integer(kind=4) :: i
integer(kind=4) :: iobs
integer(kind=4) :: it

!----------------------------------------------
! RESET GLOBAL ADJOINT VARIABLES
!----------------------------------------------
call zero_ad
x_ad(:,:)=0.0
do it = 0, nt
  call func_ross( x(:,it),fn(:,it) )
end do
#ifdef DIV
x_ad(1,nt) = x_ad(1,nt)+S_ad/float(4)*h
x_ad(1,0) = x_ad(1,0)+S_ad/float(4)*h
#endif
do it = nt, 0, -1
  do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
      do i = 1, ii
        x_ad(i,it) = x_ad(i,it)+S_ad*(2*(x(i,it)-xobs(i,iobs))/sigo**2/float(2))
      end do
    endif
  end do
enddo
do it = nt-1, 0, -1
#ifdef DIV
  x_ad(1,it+1) = x_ad(1,it+1)+S_ad*(1/float(2)/float(2))*h
  x_ad(1,it) = x_ad(1,it)+S_ad*(1/float(2)/float(2))*h
#endif
  do i = 1, ii
    fn_ad(i,it+1) = fn_ad(i,it+1)-S_ad*(2*(1/float(2))*((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/float(2))/sigm**2/float(2))*h
    fn_ad(i,it) = fn_ad(i,it)-S_ad*(2*(1/float(2))*((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/float(2))/sigm**2/float(2))*h
    x_ad(i,it+1) = x_ad(i,it+1)+S_ad*(2*(1/h)*((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/float(2))/sigm**2/float(2))*h
    x_ad(i,it) = x_ad(i,it)+S_ad*(2*((-1)/h)*((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/float(2))/sigm**2/float(2))*h
  end do
end do
do it = nt, 0, -1
  call func_ross_ad( x(:,it),x_ad(:,it),fn_ad(:,it) )
end do
do i = 1, ii
  x_ad(i,0) = x_ad(i,0)+S_ad*(2*(x(i,0)-xb(i))/sigb**2/float(2))
end do

end subroutine fwd_ad
#endif

subroutine func_ross( x, f )
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param

  implicit none

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(out) :: f(ii)
  real(kind=8), intent(in) :: x(ii)

  f(1) = (-x(2))-x(3)
  f(2) = x(1)+a*x(2)
  f(3) = b+x(1)*x(3)-c*x(3)
end subroutine func_ross

subroutine func_ross_ad( x, x_ad, f_ad )
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param

  implicit none

  !==============================================
  ! declare parameters
  !==============================================
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8

  !==============================================
  ! declare arguments
  !==============================================
  real(kind=8), intent(inout) :: f_ad(ii)
  real(kind=8), intent(in) :: x(ii)
  real(kind=8), intent(inout) :: x_ad(ii)

  x_ad(3) = x_ad(3)+f_ad(3)*(x(1)-c)
  x_ad(1) = x_ad(1)+f_ad(3)*x(3)
  f_ad(3) = 0._ikind1
  x_ad(2) = x_ad(2)+f_ad(2)*a
  x_ad(1) = x_ad(1)+f_ad(2)
  f_ad(2) = 0._ikind3
  x_ad(3) = x_ad(3)-f_ad(1)
  x_ad(2) = x_ad(2)-f_ad(1)
  f_ad(1) = 0._ikind4

end subroutine func_ross_ad


subroutine func_dw(h,dw,mm)  
  use mtmod
  implicit none
  integer(4), intent(in) :: mm
  real(8), intent(in)  :: h
  real(8), intent(out) :: dw(mm) 
  real(8) :: x, y, z
  integer(4) :: i
  do i=1,mm/2
     DO
        x = 2.0 * grnd() - 1.0
        y = 2.0 * grnd() - 1.0
        z = x*x + y*y
        if( z <= 1.0 ) exit
     END DO
     dw(2*i-1) = sqrt(h)*x*sqrt(-2.0d0*log(z)/z)
     dw(2*i  ) = sqrt(h)*y*sqrt(-2.0d0*log(z)/z)
  enddo
  if (mod(mm,2)==1) then
     DO
        x = 2.0 * grnd() - 1.0
        y = 2.0 * grnd() - 1.0
        z = x*x + y*y
        if( z <= 1.0 ) exit
     END DO
     dw(mm) = sqrt(h)*x*sqrt(-2.0d0*log(z)/z)
  endif
end subroutine func_dw

subroutine zero_ad
  !******************************************************************
  !******************************************************************
  !** This routine was generated by Automatic differentiation.     **
  !** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
  !******************************************************************
  !******************************************************************
  !==============================================
  ! referencing used modules
  !==============================================
  use param

  implicit none


  !----------------------------------------------
  ! reset adjoint module variables
  !----------------------------------------------
  call param_constructor_ad

end subroutine zero_ad
