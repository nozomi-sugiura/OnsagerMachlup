# 1 "../a.f90"
module     param
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
  implicit none

!==============================================
! declare parameters
!==============================================
  integer(kind=4), parameter :: ii = 3
  integer, parameter :: ikind2 = 8
  integer(kind=4), parameter :: nobs = 1
  integer(kind=4), parameter :: nt = 1600
!  integer(kind=4), parameter :: nt = 16000
!  integer(kind=4), parameter :: nt = 32000
  integer(kind=4), parameter :: ntd = nt/2

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: a = 0.2
  real(kind=8) :: b = 0.2
  real(kind=8) :: c = 6
  real(kind=8) :: fn(ii,0:nt)=0
  real(kind=8) :: fn_ad(ii,0:nt)=0
  real(kind=8) :: fn_tl(ii,0:nt)=0
  real(kind=8) :: h = 5.0D-4
  real(kind=8) :: sigb = 0.2
  real(kind=8) :: sigm = 2
  real(kind=8) :: sigo = 0.2
  real(kind=8) :: xb(ii)

contains
  subroutine param_constructor_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
    implicit none

!----------------------------------------------
! RESET ADJOINT MODULE VARIABLES
!----------------------------------------------
    fn_ad(:,:) = 0._ikind2

  end subroutine param_constructor_ad
end module     param

module obsdata
  use param
  implicit none
  real(8) :: xobs(ii,nobs)
  real(8) :: xo(ii,0:nt)
  real(8) :: tobs(nobs), t
  real(8) :: x_fg(ii,0:nt)
contains
  subroutine setobs
    implicit none
    real(8) :: dw(ii*nt)
    real(8) :: dw2(ii)
    integer(4) :: i, it, iobs

    tobs(1) = 0.4
!obs data almost on the attractor
    xb(1)= 2.0659834; xb(2)=-0.2977757; xb(3)= 2.0526298

    call func_dw(h,dw2,ii)  
    do i=1,ii
       x_fg(i,0) = xb(i) + sigb*dw2(i) 
    enddo
!    x_fg(1,1) = -5.90851E+00; x_fg(2,1) = -1.91864E+00; x_fg(3,1) =  -1.11507E-02
    call func_dw(h,dw,ii*nt)  
    do it=0,nt-1
       call func_ross( x_fg(:,it),fn(:,it) )
       do i=1,ii
          x_fg(i,it+1) = x_fg(i,it) + fn(i,it)*h + sigm*dw(i+it*ii)
       enddo
    enddo !firstguess

    xo(:,:) = -999
    do it=0,nt
       do iobs = 1,nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
!          if(abs(tobs(iobs)-it*h)<h/2) then
             call func_dw(1.0d0,dw2,ii)  
             do i=1,ii
                xo(i,it) = x_fg(i,it) + sigo*dw2(i)
                xobs(i,iobs) = xo(i,it) 
             enddo
          endif
       enddo
       write(11,'(a,10(1x,f14.7))') "x",it*h,x_fg(:,it),xo(:,it)
    enddo
  end subroutine setobs
end module obsdata

program    main
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use mpi
  use param
  use obsdata
  use mtmod
  implicit none

!==============================================
! declare local variables
!==============================================
  real(kind=8) :: x(ii,0:nt)
  real(kind=8) :: xx(ii,0:nt)
  real(kind=8) :: adx(ii,0:nt)
  real(8) :: adxx(ii,0:nt)=0
  integer(kind=4) :: it, itr
  integer(kind=4) :: ntr  = 100000000

  integer(kind=4) :: itr0 =  0
# 131

  real(8) :: q0, q1, logr, ratio
  real(8) ::  r=1.2d-2
  real(8) :: S=0, SS=2.0d20
  integer(8) :: acc(0:1)=0
  integer(8) :: acc_all(0:1)=0
  real(8) :: dw(ii*(nt+1))
  real(8) :: mean(ii,0:nt)=0.0  
  real(8) :: vari(ii,0:nt)=0.0  
  real(8) :: mean_all(ii,0:nt)=0.0  
  real(8) :: vari_all(ii,0:nt)=0.0  
  real(8) :: Z=0.0  
  real(8) :: Z_all=0.0  
  integer(4) :: err, rank, size

  integer(4), parameter :: mm=500
  real(8), parameter :: xmin=-5, xmax=5
  real(8) :: dx=(xmax-xmin)/mm
  real(8) :: dens(mm,mm,mm)=0.0
  real(8) :: dens_all(mm,mm,mm)=0.0
  real(8) :: dens_max=0.0 
  integer(4)::  i_map(ii)
  integer(4) :: mx, my, mz, i
  character*13 :: fname
  real(8) :: dum

  call mpi_init(err)
  call MPI_Comm_rank(MPI_COMM_WORLD,rank,err)
  call MPI_Comm_size(MPI_COMM_WORLD,size,err)

  call sgrnd(1)


  tobs(1) = 0.4
  xb(1)= 2.0659834; xb(2)=-0.2977757; xb(3)= 2.0526298
  open(11,file="../ref/fort.11")
  do it=0,nt/2
     read(11,'(1x,10(1x,f14.7))') dum,x_fg(:,it),xo(:,it)
!     if(rank.eq.0)write(0,'(1x,10(1x,f14.7))') dum,x_fg(:,it),xo(:,it)
  enddo
  close(11)
  xobs(:,1) = xo(:,nt/2) 
# 175


# 184

  xx(:,:) = x_fg(:,:)


  write(fname,'(a9,i4.4)') "rest.dat_",rank
  open(60,file=fname,form="unformatted")
  read(60) xx(:,:)
  close(60)
  write(0,*) "restart of xx is read", rank
  call sgrnd(2010+rank)
# 196

  ens_loop: do itr=1,ntr
     call func_dw(1.0d0,dw,ii*(nt+1))
!METROPOLIS REJECTION HERE
     do it=0,nt
        do i=1,ii
           x(i,it) = xx(i,it) - r**2/2*adxx(i,it) + r*dw(i+it*ii)
        enddo
     enddo
     call fwd( x,S )
     call fwd_ad( x, adx, S, 1.0d0 )

     q0   = 0.5*sum((x(:,:)-xx(:,:)+r**2/2*adxx(:,:))**2)/r**2
     q1   = 0.5*sum((xx(:,:)-x(:,:)+r**2/2* adx(:,:))**2)/r**2
     logr = -S - q1 + SS + q0
     if (logr>=0.0d0 .or. dlog(grnd()) < logr) then
        xx(:,:)   = x(:,:)
        SS        = S
        acc(1)    = acc(1) + 1
        adxx(:,:) = adx(:,:)
     else
        acc(0)    = acc(0) + 1
     endif
     call diag
     if(itr>itr0.and. mod(itr,500000)==0) call diag_out
  enddo ens_loop
  write(fname,'(a9,i4.4)') "rest.dat_",rank
  open(60,file=fname,form="unformatted")
  write(60) xx(:,:)
  close(60)
  write(0,*) "restart of xx is saved", rank
  call mpi_finalize(err)
contains
  subroutine diag
    if(mod(itr,50000)==0) then
       call mpi_allreduce(acc(0:1),acc_all(0:1),2,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,err)
       ratio = real(acc_all(1))/real(sum(acc_all(:)))
       if(rank==0) write(0,'(a3,i10,20(1x,1pe12.5))') "S= ", itr, SS, ratio, xx(:,0), r
    endif
    if(itr>itr0) then
       mean(:,:) = mean(:,:) + xx(:,:)
       vari(:,:) = vari(:,:) + xx(:,:)**2
       Z         = Z         + 1.0
!histgram
       mx=floor((xx(1,ntd)-xmin)/dx)+1
       my=floor((xx(2,ntd)-xmin)/dx)+1
       mz=floor((xx(3,ntd)-xmin)/dx)+1
       if(mx>0.and.mx<=mm .and. my>0.and.my<=mm .and. mz>0.and.mz<=mm) then
          dens(mx,my,mz) = dens(mx,my,mz)+ 1.0
       endif
    endif
  end subroutine diag

  subroutine diag_out
    call mpi_allreduce(mean(:,:),mean_all(:,:),(nt+1)*ii,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD,err)
    call mpi_allreduce(vari(:,:),vari_all(:,:),(nt+1)*ii,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD,err)
    call mpi_allreduce(Z,Z_all,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD,err)
    call mpi_reduce(dens(:,:,:),dens_all(:,:,:),mm*mm*mm,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD,err)
    if(rank==0) then
       dens_all(:,:,:) = dens_all(:,:,:)/Z_all
!map_estimate
       i_map(:) = 1
          dens_max = 0.0
          do mz=1,mm
          do my=1,mm
          do mx=1,mm
             if(dens_all(mx,my,mz)>dens_max) then
                dens_max    = dens_all(mx,my,mz)
                i_map(1)    = mx
                i_map(2)    = my
                i_map(3)    = mz
!                i_map(3)    = xmin+dx*(mz-0.5)
             endif
          enddo
          enddo
          enddo
       open(22,file="fort.22")
          do my=1,mm
             do mx=1,mm
                write(22,'(5(1x,f15.8))') xmin+dx*(mx-0.5), xmin+dx*(my-0.5), xmin+dx*(i_map(3)-0.5), dens_all(mx,my,i_map(3))/dx**3
             enddo
             write(22,'(3(1x,f15.8))') !blank line
          enddo
       close(22)
       open(23,file="fort.23")
             do mx=1,mm
                write(23,'(5(1x,f15.8))') xmin+dx*(mx-0.5), xmin+dx*(i_map(2)-0.5), xmin+dx*(i_map(3)-0.5), dens_all(mx,i_map(2),i_map(3))/dx**3
             enddo
             write(23,'(3(1x,f15.8))') !blank line
       close(23)
       mean_all(:,:) = mean_all(:,:)/Z_all
       vari_all(:,:) = vari_all(:,:)/Z_all-mean_all(:,:)**2
       do it=ntd,ntd
       write(80,'(a3,20(1x,1pe12.5))') "Out", 0.0, mean_all(:,it), vari_all(:,it), Z_all,  xmin+dx*(i_map(1)-0.5),  xmin+dx*(i_map(2)-0.5),  xmin+dx*(i_map(3)-0.5)
       enddo
       open(12,file="fort.12")
       do it=0,nt
          write(12,'(a3,20(1x,1pe12.5))') "Out", it*h, mean_all(:,it), vari_all(:,it)
       enddo
       close(12)
    endif
  end subroutine diag_out
end program    main

# 416

subroutine fwd( x, S )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use param
use obsdata

implicit none

!==============================================
! declare arguments
!==============================================
real(kind=8), intent(out) :: S
real(kind=8), intent(in) :: x(ii,0:nt)

!==============================================
! declare local variables
!==============================================
integer(kind=4) :: i
integer(kind=4) :: iobs
integer(kind=4) :: it

S = 0.0
do i = 1, ii
  S = S+(x(i,0)-xb(i))**2/sigb**2/2
end do
do it = 0, nt
  call func_ross( x(:,it),fn(:,it) )
end do
do it = 0, nt-1
  do i = 1, ii
    S = S+((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/2)**2/sigm**2/2*h
  end do
# 458

enddo
do it = 0, nt
  do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
      do i = 1, ii
        S = S+(x(i,it)-xobs(i,iobs))**2/sigo**2/2
      end do
    endif
  end do
end do
# 472

end subroutine fwd

subroutine fwd_ad( x, x_ad, S, S_ad )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use param
use obsdata

implicit none

!==============================================
! declare arguments
!==============================================
real(kind=8), intent(in) :: S
real(kind=8), intent(in) :: S_ad
real(kind=8), intent(in) :: x(ii,0:nt)
real(kind=8), intent(inout) :: x_ad(ii,0:nt)

!==============================================
! declare local variables
!==============================================
integer(kind=4) :: i
integer(kind=4) :: iobs
integer(kind=4) :: it

!----------------------------------------------
! RESET GLOBAL ADJOINT VARIABLES
!----------------------------------------------
call zero_ad
x_ad(:,:)=0.0
do it = 0, nt
  call func_ross( x(:,it),fn(:,it) )
end do
# 516

do it = nt, 0, -1
  do iobs = 1, nobs
          if(tobs(iobs)-it*h>-h/2 .and. tobs(iobs)-it*h<=h/2) then
      do i = 1, ii
        x_ad(i,it) = x_ad(i,it)+S_ad*(2*(x(i,it)-xobs(i,iobs))/sigo**2/float(2))
      end do
    endif
  end do
enddo
do it = nt-1, 0, -1
# 530

  do i = 1, ii
    fn_ad(i,it+1) = fn_ad(i,it+1)-S_ad*(2*(1/float(2))*((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/float(2))/sigm**2/float(2))*h
    fn_ad(i,it) = fn_ad(i,it)-S_ad*(2*(1/float(2))*((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/float(2))/sigm**2/float(2))*h
    x_ad(i,it+1) = x_ad(i,it+1)+S_ad*(2*(1/h)*((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/float(2))/sigm**2/float(2))*h
    x_ad(i,it) = x_ad(i,it)+S_ad*(2*((-1)/h)*((x(i,it+1)-x(i,it))/h-(fn(i,it+1)+fn(i,it))/float(2))/sigm**2/float(2))*h
  end do
end do
do it = nt, 0, -1
  call func_ross_ad( x(:,it),x_ad(:,it),fn_ad(:,it) )
end do
do i = 1, ii
  x_ad(i,0) = x_ad(i,0)+S_ad*(2*(x(i,0)-xb(i))/sigb**2/float(2))
end do

end subroutine fwd_ad


subroutine func_ross( x, f )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use param

  implicit none

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(out) :: f(ii)
  real(kind=8), intent(in) :: x(ii)

  f(1) = (-x(2))-x(3)
  f(2) = x(1)+a*x(2)
  f(3) = b+x(1)*x(3)-c*x(3)
end subroutine func_ross

subroutine func_ross_ad( x, x_ad, f_ad )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use param

  implicit none

!==============================================
! declare parameters
!==============================================
  integer, parameter :: ikind1 = 8
  integer, parameter :: ikind3 = 8
  integer, parameter :: ikind4 = 8

!==============================================
! declare arguments
!==============================================
  real(kind=8), intent(inout) :: f_ad(ii)
  real(kind=8), intent(in) :: x(ii)
  real(kind=8), intent(inout) :: x_ad(ii)

  x_ad(3) = x_ad(3)+f_ad(3)*(x(1)-c)
  x_ad(1) = x_ad(1)+f_ad(3)*x(3)
  f_ad(3) = 0._ikind1
  x_ad(2) = x_ad(2)+f_ad(2)*a
  x_ad(1) = x_ad(1)+f_ad(2)
  f_ad(2) = 0._ikind3
  x_ad(3) = x_ad(3)-f_ad(1)
  x_ad(2) = x_ad(2)-f_ad(1)
  f_ad(1) = 0._ikind4

end subroutine func_ross_ad


subroutine func_dw(h,dw,mm)  
  use mtmod
  implicit none
  integer(4), intent(in) :: mm
  real(8), intent(in)  :: h
  real(8), intent(out) :: dw(mm) 
  real(8) :: x, y, z
  integer(4) :: i
  do i=1,mm/2
     DO
        x = 2.0 * grnd() - 1.0
        y = 2.0 * grnd() - 1.0
        z = x*x + y*y
        if( z <= 1.0 ) exit
     END DO
     dw(2*i-1) = sqrt(h)*x*sqrt(-2.0d0*log(z)/z)
     dw(2*i  ) = sqrt(h)*y*sqrt(-2.0d0*log(z)/z)
  enddo
  if (mod(mm,2)==1) then
     DO
        x = 2.0 * grnd() - 1.0
        y = 2.0 * grnd() - 1.0
        z = x*x + y*y
        if( z <= 1.0 ) exit
     END DO
     dw(mm) = sqrt(h)*x*sqrt(-2.0d0*log(z)/z)
  endif
end subroutine func_dw

subroutine zero_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 3.5.2   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
  use param

  implicit none


!----------------------------------------------
! reset adjoint module variables
!----------------------------------------------
  call param_constructor_ad

end subroutine zero_ad
